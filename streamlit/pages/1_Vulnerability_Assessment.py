import pandas as pd
from snowflake.snowpark import Session
from snowflake.snowpark.types import StringType
from snowflake.snowpark import functions as F
from snowflake.snowpark import types as T
import folium
import streamlit as st
from streamlit_folium import  folium_static
import geopandas as gpd
import streamlit.components.v1 as components
import contextily as cx
from datetime import datetime, timedelta
import os,json



#####load secrets

with open('Hackathon_Submission/creds.json') as f:  #'creds-Copy1.json'
    data = json.load(f)
    username = data['username']
    password = data['password']
    account = data['account']
    role = data['role']
    database = data['database']
    schema = data['schema']
    warehouse = data['warehouse']


 

###Set the streamlit page layout
st.set_page_config(layout="wide")

###Create Connection to Snowflake
@st.cache_resource(ttl=3600)
def get_db_session():

    CONNECTION_PARAMETERS = {
    'url': account,
    'ACCOUNT': account,
    'user': username,
    'password': password,
    'database': database,
    'warehouse': warehouse,
    'role': role,
    'schema': schema
    }
    return Session.builder.configs(CONNECTION_PARAMETERS).create()

session = get_db_session()

session.sql('''USE DATABASE "Vunerability Assessment"''').collect()
st.title('VULNERABILITY ASSESSMENT EXAMPLE')
st.subheader('Understanding Vunerabilities accross a specific area in UK and how this impacts energy consumption')

#load snowpark tables


geohealth_life_grouped_postcode = session.table('"Live_Expectancy_grouped_by_postcode"')

postcodes = session.table('UK_POSTCODES')

postcodes_longlat = postcodes.select('"Postcode"',F.round('LONGITUDE',6).alias('LONGITUDE'),F.round('LATITUDE',6).alias('LATITUDE'))\
.with_column('POINT',F.call_function('ST_MAKEPOINT',F.col('LONGITUDE'),F.col('LATITUDE')))

LSOAS = session.table('LSOA_BOUNDARIES')

PostcodeLSOALookup = session.table('"PostcodeLSOALookup"')

UK_HOUSEHOLDS = session.table('UK_HOUSEHOLDS')
OA_CODES = session.table('"OA2011 to OA2021 Lookup"')
OA_BOUNDARIES = session.table('"OA Boundaries 2021"')
LSOA1121 = session.table('"LSOA2011 to LOSA2021 Lookup"')

ELECTRICITY = session.table('LSOA_DOMESTIC_ELECTRICITY')
GAS = session.table('LSOA_DOMESTIC_GAS')

Weather_Daily = session.table('WEATHER_DATA_DAILY_SUMMARY')
Weather_SSPA = session.table('SSPA_DETAILS')


def retrieve_household_info_1_postcode(postcode):
    return UK_HOUSEHOLDS\
    .filter(F.col('POSTCODE')==postcode)\
    .group_by(F.col('POSTCODE'))\
    .agg(F.cast(F.avg('INCOME_RANK'),T.IntegerType()).alias('INCOME_RANK'),
    F.cast(F.avg('VULNERABILITY_INDEX'),T.IntegerType()).alias('VUNERABILITY_INDEX'),
    F.cast(F.sum('LONG_TERM_UNEMPLOYED'),T.DecimalType(10,2)).alias('LONG_TERM_UNEMPLOYED'),
    F.cast(F.avg('HOUSEHOLD_INCOME_MODELLED'),T.DecimalType(10,2)).alias('HOUSEHOLD_INCOME_REMODELLED'),
    F.cast(F.avg('RESIDENTS_AGED_75_OR_OVER_MEAN_NO_PER_HOUSEHOLD'),T.DecimalType(10,2)).alias('RESIDENTS_AGED_75_OR_OVER_MEAN_NO_PER_HOUSEHOLD'),
    F.mode('HEATING_FUEL').alias('FUEL_TYPE'),
    F.mode('CURRENT_EPC_RATING').alias('CURRENT_EPC_RATING'),
    F.mode('POTENTIAL_EPC_RATING').alias('POTENTIAL_EPC_RATING'))


##### functions
def retrieve_pcode_info(postcode):
    household = retrieve_household_info_1_postcode(postcode)
    return postcodes_longlat.filter(F.col('"Postcode"')==postcode)\
    .with_column_renamed('POINT','SELECTED_POINT')\
    .join(geohealth_life_grouped_postcode, postcodes_longlat['"Postcode"'] == geohealth_life_grouped_postcode['PCDS'])\
    .join(household,postcodes_longlat['"Postcode"']==household['POSTCODE'])








def retrieve_postcodes_of_distance(postcode,distance):
    postcode_info = retrieve_pcode_info(postcode)
    return postcodes_longlat.join(postcode_info,
                    F.call_function('ST_DISTANCE',
                                    F.col('POINT'),
                                    F.col('SELECTED_POINT'))<=F.lit(distance),rsuffix='_selected')\
                                    .drop('"Postcode_selected"','LONGITUDE_SELECTED','LATITUDE_SELECTED','SELECTED_POINT')



def life_expectancy_lsoa_distance(postcode,distance):
    selected_pc = retrieve_pcode_info(postcode)
    return PostcodeLSOALookup\
    .join(geohealth_life_grouped_postcode,F.col('"Postcode"')== F.col('PCDS'))\
    .group_by(F.col('LSOA21CD')).agg(F.any_value('LSOA21NM'),
    F.any_value('GEOGRAPHY').alias('GEOGRAPHY'),
    F.avg('LIFE_EXPECTANCY').alias('LIVE_EXPECTANCY'),
    F.avg('BIOLOGICAL_AGE').alias('BIOLOGICAL_AGE'),
    F.avg('AGE_OF_DEATH').alias('AGE_OF_DEATH'))\
    .join(selected_pc.select('"SELECTED_POINT"'),F.call_function('ST_DWITHIN',F.col('SELECTED_POINT'),F.col('GEOGRAPHY'),distance))\
    .drop("SELECTED_POINT")


def households_lsoa(postcode,distance):

    df = life_expectancy_lsoa_distance(postcode,distance)
    OAdf = OA_BOUNDARIES.select('OA21CD','LSOA21CDM')
    OA11df = OA_CODES.select('OA21CD','OA11CD')
    life_expectancy_lsoas = df\
    .join(OAdf,OAdf['LSOA21CDM']==df['LSOA21CD'])\
    .join(OA11df, OA11df['OA21CD'] == OAdf['OA21CD'],lsuffix = 'L_').select('OA11CD','LSOA21CD','LIVE_EXPECTANCY','BIOLOGICAL_AGE','AGE_OF_DEATH','GEOGRAPHY')\
    .join(UK_HOUSEHOLDS,F.col('OA11CD')==F.col('OUTPUT_AREA_2011CENSUS'))

    lsoa_stats = life_expectancy_lsoas.group_by('LSOA21CD').agg(F.round(F.any_value('BIOLOGICAL_AGE'),0).alias('BIOLOGICAL_AGE'),
                                                                            F.round(F.any_value('AGE_OF_DEATH'),0).alias('AGE_OF_DEATH'),
                                                                            F.any_value('GEOGRAPHY').alias('GEOGRAPHY'),
                                                                            F.mode('PROPERTY_TYPE').alias('TYPICAL_PROPERTY_TYPE'),
                                                                            F.mode('PROPERTY_STYLE').alias('TYPICAL_PROPERTY_STYLE'),
                                                                            F.round(F.mean('MODELLED_NO_OF_ROOMS'),0).alias('AVG_NUMBER_OF_ROOMS'),
                                                                            F.mode('HEATING_FUEL').alias('FUEL_TYPE'),
                                                                            F.mode('CURRENT_EPC_RATING').alias('TYPICAL_EPC_RATING'),
                                                                            F.round(F.avg('VULNERABILITY_INDEX'),0).alias('VULNERABILITY_INDEX'),
                                                                            F.round(F.avg('HOUSEHOLD_INCOME_MODELLED'),0).alias('AVERAGE_INCOME')

                                                                            ).with_column('WKT',F.call_function('ST_ASWKT',F.col('GEOGRAPHY')))\
                                                                            
    
    
    return lsoa_stats

@st.cache_data
def weather(postcode,distance,year):
 
    SSPA = Weather_SSPA.with_column('POINT', F.call_function('ST_MAKEPOINT',F.col('"LONG"'),F.col('LAT')))
    LSOAs = households_lsoa(postcode,distance).select('LSOA21CD','GEOGRAPHY')
    Weather_site_LSOA = LSOAs.join(SSPA,F.call_function('ST_DWITHIN'
                                    ,F.col('POINT')
                                    ,F.col('GEOGRAPHY')
                                    ,2000))\
    .with_column('DISTANCE',
        F.call_function('ST_DISTANCE',
        F.col('POINT'),
        F.call_function('ST_CENTROID',
        F.col('GEOGRAPHY'))))\
        .group_by('"SiteID"').agg(F.call_function('MIN_BY'
        ,F.col('"SiteID"')
        ,F.col('"DISTANCE"')).alias('SITE_ID')
        ,F.any_value('"Site_name"').alias('SITE_NAME')
        ,F.min('DISTANCE').alias('DISTANCE_FROM_SITE'))
    Weather_det = Weather_Daily.with_column('DATE',F.call_function('TRY_TO_DATE',(F.cast('"Valid Day (06-21Z)"',T.StringType()),'YYYYMMDD')))\
    .drop('"Valid Day (06-21Z)"').filter(F.year('DATE')==year)
    
    return Weather_det.join(Weather_site_LSOA,Weather_site_LSOA['SITE_ID']==Weather_det['"SSPA Identifier"']).to_pandas()
    


@st.cache_data
def electric(postcode,distance):

    LSOAs = households_lsoa(postcode,distance).select('LSOA21CD')
    Elect_LSOA = ELECTRICITY.select(F.col('"Year"').alias('YEAR'),F.col('"LSOA code"').alias('LSOA11CD'),F.round(F.col('"Mean consumption (kWh per meter)"'),2)\
                .alias('"Mean Electric Consumption per meter"'))
    GasLSOA = GAS.select(F.col('"Year"').alias('YEAR'),F.col('"LSOA code"').alias('LSOA11CD'),F.round(F.col('"Mean  consumption (kWh per meter)"'),2)\
                .alias('"Mean Gas Consumption per meter"'))

    Elec_Gas_LSOA = Elect_LSOA.join(GasLSOA, 
                                    (GasLSOA['LSOA11CD'] == Elect_LSOA['LSOA11CD']) & (GasLSOA['YEAR'] ==Elect_LSOA['YEAR'] ),
                                    lsuffix='L').drop('YEARL','LSOA11CDL')
    
    Elec_Gas_LSOA = Elec_Gas_LSOA.join(LSOA1121.select('LSOA11CD','LSOA21CD'),'LSOA11CD').drop('LSOA11CD')
    Elec_Gas_LSOA = Elec_Gas_LSOA.join(LSOAs,'LSOA21CD').group_by(F.col('YEAR')).agg(F.mean('"Mean Electric Consumption per meter"').alias('"Mean Electric Consumption per meter"'),
                                                                                     F.mean('"Mean Gas Consumption per meter"').alias('"Mean Gas Consumption per meter"'))


    return Elec_Gas_LSOA.to_pandas()

@st.cache_data
def lsoa_stats(postcode,distance):
    return households_lsoa(postcode,distance).to_pandas()

@st.cache_data
def summary_stats(postcode,distance):
    return households_lsoa(postcode,distance)\
        .group_by().agg(F.round(F.avg('VULNERABILITY_INDEX'),0).alias('VULNERABILITY_INDEX'),
                        F.round(F.any_value('AGE_OF_DEATH'),0).alias('AGE_OF_DEATH'),
                        F.round(F.mean('AVG_NUMBER_OF_ROOMS'),0).alias('AVG_NUMBER_OF_ROOMS'),
                        F.round(F.avg('AVERAGE_INCOME'),0).alias('AVERAGE_INCOME')
                        )\
        .to_pandas()


@st.cache_data
def weather_columns():
    columns = Weather_Daily.drop('"Valid Day (06-21Z)"','"SSPA Identifier"',
                                 '''"Total Duration of weather type 'Full Sun' in the period 06-21Z "''',
                                 '''"Percentage of daytime period with weather type 'Full Sun'"''').columns
    refactored = [s.strip('"') for s in columns]
    return refactored

@st.cache_data
def measure_columns():
    return households_lsoa(postcode,distance).select('BIOLOGICAL_AGE','AGE_OF_DEATH','AVG_NUMBER_OF_ROOMS','VULNERABILITY_INDEX','AVERAGE_INCOME').columns

@st.cache_data
def postcodes_pd(postcode):
    return retrieve_pcode_info(postcode).to_pandas()

distance_in_metres = 2000

with st.sidebar:
    postcode = st.text_input('Enter Postcode','DY13 9GN')
    distance = st.slider('Distance away from postcode in Metres', 1,3000,500)
    

    st.markdown('##### Heatmap options')
    measure = st.selectbox('Choose Measure:',measure_columns())
    st.markdown('##### Weather options')
    year = st.slider('Choose Weather Year',2013,2023)
    Wmeasure = st.selectbox('Choose Weather Measure',weather_columns())



postcode_info = postcodes_pd(postcode)

df = lsoa_stats(postcode,distance)




geodframe = df.set_geometry(gpd.GeoSeries.from_wkt(df['WKT']))
geodframe.crs = "EPSG:4326"
geojson = geodframe.to_json(drop_id=True)

m = folium.Map(location=[postcode_info.LATITUDE.iloc[0],postcode_info.LONGITUDE.iloc[0]],tiles="cartodbpositron", zoom_start=12)

feature_gp4 = folium.FeatureGroup(name = "Selected Postcode")

html = f'''<body style="background-color:#F0F0F0;">
<p style="font-family:verdana"> 
<b>Selected Post Code Details</b><BR><BR><BR>
<b>Latitude:</b>  {postcode_info.LATITUDE.iloc[0]}<BR>
<b>Longitude:</b>        {postcode_info.LONGITUDE.iloc[0]} <BR>
<b>Postcode:</b> {postcode_info.Postcode.iloc[0]} <BR>
<b>Biological Age:</b> {postcode_info.BIOLOGICAL_AGE.iloc[0]} <BR>
<b>Life Expectancy:</b> {postcode_info.LIFE_EXPECTANCY.iloc[0]} <BR>
<b>Age of Death:</b> {postcode_info.AGE_OF_DEATH.iloc[0]} <BR>
<b>Fuel Type:</b> {postcode_info.FUEL_TYPE.iloc[0]} <BR>
<b>Long Term Unemployed:</b> {postcode_info.LONG_TERM_UNEMPLOYED.iloc[0]} <BR>
<b>Household Income Remodelled:</b> {postcode_info.HOUSEHOLD_INCOME_REMODELLED.iloc[0]} <BR>
<b>Vunerability Index:</b> {postcode_info.VUNERABILITY_INDEX.iloc[0]} <BR>
</p>
'''

iframe = folium.IFrame(html,width=400,height=350)
popup = folium.Popup(iframe,max_width=400)




M1 = folium.Marker(postcode_info[['LATITUDE', 'LONGITUDE']].iloc[0].to_numpy(),
                   name = 'selected bustop',popup = popup, 
                   icon=folium.Icon(color='blue', prefix='fa',icon='house'), icon_size=(40,40)).add_to(feature_gp4)



cp1 = folium.Choropleth(
                geo_data = geojson,
                name = 'Household Vulnerabilities',
                data = geodframe,
                columns = ['LSOA21CD',measure],
                key_on = 'properties.LSOA21CD',
                fill_color = 'RdYlBu',
                legend_name = measure,
                fill_opacity = 0.6,
                line_opacity = 0.3,
                line_color='black',
                smooth_factor = 0,
                highlight = True
                ).add_to(m)

cp1.geojson.add_child(
                folium.features.GeoJsonTooltip(['VULNERABILITY_INDEX',
                                                'BIOLOGICAL_AGE',
                                                'AGE_OF_DEATH',
                                                'AVG_NUMBER_OF_ROOMS',
                                                'AVERAGE_INCOME',
                                                'LSOA21CD'
                                    
                                    
                                    ]))

feature_gp4.add_to(m)
folium.LayerControl().add_to(m)

col1,col2,col3,col4 = st.columns(4)
with col1:
    st.metric('Vulnerability Index',int(summary_stats(postcode,distance).VULNERABILITY_INDEX.iloc[0]))
with col2:
    st.metric('Age of Death',summary_stats(postcode,distance).AGE_OF_DEATH.iloc[0])
with col3:
    st.metric('Avg Number of Rooms',summary_stats(postcode,distance).AVG_NUMBER_OF_ROOMS.iloc[0])

with col4:
    st.metric('Avg Income',int(summary_stats(postcode,distance).AVERAGE_INCOME.iloc[0]))

#st.table(df.drop(columns=['WKT']))
folium_static(m, width=1200, height= 800)




import altair as alt


a = alt.Chart(electric(postcode,distance).reset_index()).mark_line().transform_fold(
                                    fold = ['Mean Electric Consumption per meter'
                                            ,'Mean Gas Consumption per meter']
                                            , as_=['variable','value']).encode(x='YEAR',
                                                                             y=alt.Y('Mean Electric Consumption per meter',title=''),
                                                                             color=alt.value("#FFAA00"))
b = alt.Chart(electric(postcode,distance).reset_index()).mark_line().encode(x='YEAR', y=alt.Y('Mean Gas Consumption per meter'))

source = alt.layer(a,b).configure_axis(
    grid=False)


col10,col11 = st.columns(2)

with col10:
    st.markdown('##### Electric and Gas Consumption per Square Metre by Year')
    st.altair_chart(source, use_container_width=True)




c = a = alt.Chart(weather(postcode,distance,year).reset_index()).mark_line().encode(x='DATE',
                                                                             y=alt.Y(Wmeasure.strip('"'),title=''),
                                                                             color=alt.value("#FFAA00"),tooltip='DATE')

with col11:
    st.markdown('##### Weather data throughout the year')
    st.altair_chart(c, use_container_width=True)

