schemaVersion: 3
meta:
  sourceVersionId: 3de8067b-cb6b-49e9-b6b0-ac01dbe49c56 # DO NOT CHANGE - Hex uses this to match up project versions when reimporting the file
  description: Here is a walk though of applying several Hackathon datasets to analyse population vulnerabilities.
  projectId: 7d8c94a6-9345-449b-ade3-bd21f32a5922 # DO NOT CHANGE - Unique ID of the project from which this file was generated
  title: Vulnerability Assessment
  timezone: null
  appTheme: SYS_PREF
  codeLanguage: PYTHON
  status: null
  categories: []
  castDecimalsDefault: true
  logicQueryCacheTimeout: null
  publishedQueryCacheTimeout: null
projectAssets:
  dataConnections:
    - dataConnectionId: 06ba2743-b756-4462-af67-91cfb09cff6c # Vulnerability Assessment Datasets (snowflake)
  envVars: []
  secrets: []
sharedAssets:
  secrets: []
  vcsPackages: []
  dataConnections: []
  externalFileIntegrations: []
cells:
  - cellType: TEXT
    cellId: ad20829f-e3b4-4542-b38f-61015ce546b3 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Firstly I am going to establish a connection to Snowflake
  - cellType: CODE
    cellId: 8bde6fba-7d5d-4539-971c-23b147d12421 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        import hextoolkit
        hex_snowflake_conn = hextoolkit.get_data_connection('Vulnerability Assessment Datasets')
        session = hex_snowflake_conn.get_snowpark_session()
        from snowflake.snowpark import functions as F
        from snowflake.snowpark import types as T
  - cellType: TEXT
    cellId: 04470c74-bae3-4f50-9db1-3ab24d6ecf55 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: We will go into SQL  to add views from a selection of shared datasets
  - cellType: MARKDOWN
    cellId: f86bd58a-3b5e-443c-beea-f6543e8617df # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        #### 1. Hover under this cell and click 'Add' - then select SQL

        #### 2 In the top left, ensure the Snowflake connection is selected

        #### 3. Copy and paste the following into the SQL cell

        CREATE OR REPLACE VIEW LSOA_BOUNDARIES AS SELECT * FROM ONS.CURATED."lSOA Boundaries 2021";

        CREATE OR REPLACE VIEW UK_HOUSEHOLDS AS SELECT * FROM UK_HOUSEHOLDS.ARK_MARKETPLACE.UK_HOUSEHOLDS;

        CREATE OR REPLACE VIEW UK_POSTCODES AS SELECT * FROM  OS.CURATED."UK Postcodes with Points";

        CREATE OR REPLACE VIEW LSOA_DOMESTIC_GAS AS SELECT * FROM ONS.CURATED."LSOA Domestic Gas 2010 to 2021";

        CREATE OR REPLACE VIEW LSOA_DOMESTIC_ELECTRICITY AS 
        SELECT * FROM ONS.CURATED."LSOA Domestic Electricity 2010 - 21";

        CREATE OR REPLACE VIEW "OA2011 to OA2021 Lookup" AS SELECT * FROM ONS.CURATED."OA2011 to OA2021 Lookup";

        CREATE OR REPLACE VIEW "LSOA2011 to LOSA2021 Lookup" as 
        SELECT * FROM ONS.CURATED."LSOA 2011 to LSOA 2021 Lookup Table";

        create or replace view "OA Boundaries 2021" as select * from ONS.CURATED."OA Boundaries 2021";

  - cellType: TEXT
    cellId: 6e4b1026-26dc-4cfe-931a-2dbe90f3fff0 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Run the cell below. Once complete click on the geohealth_life_expectancyL dataframe (its highlighted with a blue background under the cell) and select view as table display
  - cellType: CODE
    cellId: e6133400-c049-43b1-afa5-87b771af3f4a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Geohealth life expectancyl
    config:
      source: |-
        session.table('"MORE_METRICS_DATA_FOR_HACKATHON"."GEOHEALTH"."MOST_RECENT_GEOHEALTH_POSTCODE_SEX_AGE"')\
        .create_or_replace_view('MOST_RECENT_GEOHEALTH_POSTCODE_SEX_AGE')
            
        geohealth_life_expectancy = session.table('MOST_RECENT_GEOHEALTH_POSTCODE_SEX_AGE')
        geohealth_life_expectancyL = geohealth_life_expectancy.sample(0.1).limit(5)
  - cellType: MARKDOWN
    cellId: fd40306e-132f-4f9a-8229-2d4090bd8f92 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        #### We will now Group the data by Postcode with ages and life expectancies

        1. #### Run the cell below and then add a table display for geohealth_life_grouped_postcodeL as before

  - cellType: CODE
    cellId: 204d734e-b0ce-466a-9c80-f2c463fa6f19 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        geohealth_life_grouped_postcode = geohealth_life_expectancy.group_by('PCDS')\
        .agg(F.round(F.avg('LIFE_EXPECTANCY'),2).alias('LIFE_EXPECTANCY'),
        F.round(F.avg('BIOLOGICAL_AGE'),2).alias('BIOLOGICAL_AGE'))\
        .with_column('AGE_OF_DEATH',F.round(F.col('LIFE_EXPECTANCY')+F.col('BIOLOGICAL_AGE'),2))\
        .write.mode("overwrite").save_as_table('"Live_Expectancy_grouped_by_postcode"')

        geohealth_life_grouped_postcode = session.table('"Live_Expectancy_grouped_by_postcode"')

        geohealth_life_grouped_postcodeL = geohealth_life_grouped_postcode.limit(1)
  - cellType: MARKDOWN
    cellId: 9a94f781-5b61-41c5-8344-8c7f4700cc97 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### The data is by postcode - so lets bring postcode details into the session

        View a sample of PostcodesL by  creating a table display from postcodesL
  - cellType: CODE
    cellId: 4fa0bf1a-6819-4a82-a70c-5d8ff96f045b # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        postcodes = session.table('UK_POSTCODES')
        PostcodesL = postcodes.sample(0.1).limit(10)
  - cellType: MARKDOWN
    cellId: 2ffac92c-5b25-49df-abea-e3f8fecd953d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        Lets  create a point for every UK postcode - Using .show() allows you to view the data in plain text format

  - cellType: CODE
    cellId: a6adde6d-d089-40b3-9ebd-d3b28a40080f # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        postcodes_longlat = postcodes.select('"Postcode"',F.round('LONGITUDE',6).alias('LONGITUDE'),F.round('LATITUDE',6).alias('LATITUDE'))\
        .with_column('POINT',F.call_function('ST_MAKEPOINT',F.col('LONGITUDE'),F.col('LATITUDE')))
        postcodes_longlat.show(1)
  - cellType: TEXT
    cellId: fbe8528e-81ab-431a-90dd-34628790ddc1 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Lets add the LSOAS to the postcodes to provide a lookup.  Instead of viewing the data, here we are viewing the columns to get an idea of column headers
  - cellType: CODE
    cellId: 4285b605-6169-4331-836f-e8028cde6fff # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Lsoas 1
    config:
      source: |-
        LSOAS = session.table('LSOA_BOUNDARIES')
        LSOAS.columns
        LSOAS_1 = LSOAS.limit(1)
  - cellType: MARKDOWN
    cellId: e7da151b-fe02-4a7c-bc58-7b1d56fb3f50 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        ##### Below press Add and add a map
        1. In data select LSOA_1

        2. In type select Area

        Under Area in Custom select GEOGRAPHY
         
        You should now see a polygon inside a map which is the area inside the first LSOA polygon in the datasset

  - cellType: TEXT
    cellId: 527994c1-d21b-4d07-a29f-ded4e06ee0ad # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: We will then add our LSOA codes to postcodes.  You will see that we are creating a geospatial join which codes a postcode to the LSOA code that is completely within the polygon
  - cellType: CODE
    cellId: 3f4e11b7-f683-424b-80a6-7535fce18dd6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        PostcodeToLSOA21 = postcodes_longlat.join(LSOAS,F.call_function('ST_WITHIN',(F.col('POINT'),F.col('GEOGRAPHY'))))\
        .select('"Postcode"','LSOA21CD','LSOA21NM','GEOGRAPHY')\
        .write.mode("overwrite").save_as_table('"PostcodeLSOALookup"')
        PostcodeLSOALookup = session.table('"PostcodeLSOALookup"')
        PostcodeLSOALookupL =  PostcodeLSOALookup.limit(5) ####<<<<<<<Create a table display if you want to see what the data looks like for 5 rows
  - cellType: TABLE_DISPLAY
    cellId: 62474163-ce1a-4346-8314-126358ec8e06 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      dataFrameVariableName: PostcodeLSOALookupL
      resultVariable: table_result_14
      tableDisplayConfig:
        pageSize: 50
        height: null
        hideIcons: false
        hideIndex: false
        defaultSortColumn: null
        defaultSortIndexColumn: null
        defaultSortDirection: ASC
        conditionalFormatting: null
        filters: null
        columnProperties:
          - originalName: GEOGRAPHY
            renameTo: null
            size: 400
            wrapText: null
            displayFormat: null
          - originalName: LSOA21CD
            renameTo: null
            size: 114
            wrapText: null
            displayFormat: null
          - originalName: LSOA21NM
            renameTo: null
            size: 116
            wrapText: null
            displayFormat: null
          - originalName: Postcode
            renameTo: null
            size: 105
            wrapText: null
            displayFormat: null
        columnOrdering: null
        pinnedColumns: null
        hiddenColumns: null
  - cellType: MARKDOWN
    cellId: fd0e0d32-899b-4a09-a587-e3eb6e561a9d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        Next, lets join our Postcodes which now has the LSOA codes to the house hold dataset which we have previously grouped by postcode
        I have now dropped the geography column as I do not need it as the dataset now contains the LSOA code.
  - cellType: CODE
    cellId: 1157f0ef-1a08-4b01-95ac-c6d9428a1dbb # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: PostcodeLSOALookup.join(geohealth_life_grouped_postcode,F.col('"Postcode"')== F.col('PCDS')).drop('GEOGRAPHY').show()
  - cellType: TEXT
    cellId: 89de3a33-d06c-407b-95f9-59daf1ee9331 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Lets create a simple filter based on postcode - In this instance, I am filtering to view the first 5 records of postcodes near where I live
  - cellType: CODE
    cellId: 2517331f-796a-4dbf-8ec0-20e2335c1ab6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: PostcodeLSOALookup.filter(F.col('"Postcode"').like('DY13%')).drop('GEOGRAPHY').show(5)
  - cellType: TEXT
    cellId: 3f00d770-9bb4-499b-9b21-9779f59a938f # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Lets look at a summary of the Average age of Death near where I live - and initially filtering the results by postcode.  You will note that i am joining the results to the health dataset AFTER i have filtered the postcodes.  Also, note that I am only grouping by LSOACD and all other columns are aggregations - including the GEOGRAPHY column.
  - cellType: CODE
    cellId: 4b026803-0236-4998-8c48-f311dc925138 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |
        life_expectancy_lsoa = PostcodeLSOALookup.filter(F.col('"Postcode"').like('DY%')).join(geohealth_life_grouped_postcode,F.col('"Postcode"')== F.col('PCDS'))\
        .group_by(F.col('LSOA21CD')).agg(F.any_value('LSOA21NM'),
        F.any_value('GEOGRAPHY'),
        F.avg('LIFE_EXPECTANCY'),
        F.avg('BIOLOGICAL_AGE'),
        F.avg('AGE_OF_DEATH'))
  - cellType: MARKDOWN
    cellId: afbbc519-8bc9-4615-b42f-3bbcbef16922 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### Below add a new map
        1.  In data choose life Expectancy
        2. In Type choose Area
        3. In Custom select ANY_VALUE(GEOGRAPHY)
        4. In fill select colour based on data
        5. Choose one of the measures in 'BASED ON' to create a heat map
  - cellType: MARKDOWN
    cellId: 28d5a1fa-f464-41ac-bf56-c28a5514e867 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "#### We will then create 3 more dataframes from other shared datasets.  UK Households is information which contains statistical demographics at postccode level which includes the Vunerability index"
  - cellType: CODE
    cellId: 14ae8abd-36b5-4a48-99fa-a76f5fadc9dd # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        UK_HOUSEHOLDS = session.table('UK_HOUSEHOLDS')
        OA_CODES = session.table('"OA2011 to OA2021 Lookup"')
        OA_BOUNDARIES = session.table('"OA Boundaries 2021"')
  - cellType: TEXT
    cellId: 17f03319-287e-4b85-8c60-360b4ab38541 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          indent: 1
          children:
            - text: Here i am having a look at the household data columns. -  There is a lot of statistical information so viewing the columns is useful.  -  However, I would like to group to LSOA boundaries as well.  We cannot do this the moment - however we do have the OA codes - which provides even more granualar detail than LSOA.  We just loaded the OA boundaries into a data frame.  Also, this dataset has the slightly older OA codes (based on 2011 census.  You ave just loaded a table which includes the lookups between the old and new codes.  We will use this to 'upgrade' the dataset with the new codes.
  - cellType: CODE
    cellId: 7a28f21c-3796-4d5b-acf3-ccf214dac095 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: UK_HOUSEHOLDS.columns[0:100]
  - cellType: TEXT
    cellId: 0f4ce259-521a-4e08-8c18-9be4d2e17dfe # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Here, i am grouping together to OA census level.  To display the data, select the Households_Grouped_By_OAL dataframe (highlighted in blue) and click on view as table display
  - cellType: CODE
    cellId: 2e02e92e-e0e8-457f-9585-ac64100505ee # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Households grouped by oal
    config:
      source: |-
        Households_Grouped_By_OA = UK_HOUSEHOLDS\
        .filter(F.col('POSTCODE').like('DY%'))\
        .group_by(F.col('OUTPUT_AREA_2011CENSUS'))\
        .agg(F.cast(F.avg('INCOME_RANK'),T.IntegerType()).alias('INCOME_RANK'),
        F.cast(F.avg('VULNERABILITY_INDEX'),T.IntegerType()).alias('VUNERABILITY_INDEX'),
        F.cast(F.sum('LONG_TERM_UNEMPLOYED'),T.DecimalType(10,2)).alias('LONG_TERM_UNEMPLOYED'),
        F.cast(F.avg('HOUSEHOLD_INCOME_MODELLED'),T.DecimalType(10,2)).alias('HOUSEHOLD_INCOME_REMODELLED'),
        F.cast(F.avg('RESIDENTS_AGED_75_OR_OVER_MEAN_NO_PER_HOUSEHOLD'),T.DecimalType(10,2)).alias('RESIDENTS_AGED_75_OR_OVER_MEAN_NO_PER_HOUSEHOLD'),
        F.mode('HEATING_FUEL').alias('FUEL_TYPE'),
        F.mode('CURRENT_EPC_RATING').alias('CURRENT_EPC_RATING'),
        F.mode('POTENTIAL_EPC_RATING').alias('POTENTIAL_EPC_RATING'))

        Households_Grouped_By_OAL = Households_Grouped_By_OA.limit(10)
  - cellType: TEXT
    cellId: bf708c26-8140-4b80-a817-4c0a47439a03 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: We have boundaries for OA21 codes.  The data provided is linked to OA11 codes - lets use a lookup table to re code to the right OA codes. Run the below code and create a table display from the dataframe
  - cellType: CODE
    cellId: bc50740d-c1aa-41fb-befc-beddf64cdab1 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: OA_CODESL = OA_CODES.limit(10)
  - cellType: TEXT
    cellId: c5a0f826-0278-4775-9b29-c8ef39af7bc3 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Join OA to the most recent codes.  Create a table display from the limited sample.
  - cellType: CODE
    cellId: fa51a8f5-92e8-4766-b34e-30c4cd24fc9d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        Households_with_boundary_codes = Households_Grouped_By_OA.join(OA_CODES.select('OA11CD','OA21CD','LAD22CD','LAD22NM'),
        F.col('OUTPUT_AREA_2011CENSUS')==F.col('OA11CD'))
        Households_with_boundary_codesL = Households_with_boundary_codes.sample(0.1).limit(5)
  - cellType: TEXT
    cellId: 0517b3f1-7174-4e07-a051-3f99db52de53 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Lets have a look at the OA21 Bboundaries - we have a geography column which is our boundary
  - cellType: CODE
    cellId: 5723122e-f401-4216-bd9b-14fe53feefa4 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "OA_BOUNDARIES.columns "
  - cellType: TEXT
    cellId: fc79ebd4-ac3b-4102-adb4-84d7b81562aa # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Now lets join to our households dataset - remember we have already filted this based on where you live
  - cellType: CODE
    cellId: c728f756-e277-4f3d-8b61-b590d64c7edf # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Households_with_OA_Boundaries = Households_with_boundary_codes.join(OA_BOUNDARIES,'OA21CD' )
  - cellType: MARKDOWN
    cellId: f7757f15-b5ca-4964-90ad-35506f8abab1 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        #### Create a Vunerability Index by OA heat map

        1. Below select add and choose map
        2. In Area select households with OA boundaries
        3. In Type select area
        4. In Custom select Geography
        5. In Color based on data select Vunerability Index

  - cellType: TEXT
    cellId: c5c0b4d2-3969-435e-a564-78237d6cd0f1 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Now, lets aggregate to LSOA which gives a lower level of detail - but the same level as the previous data set.  NB i am selecting the mode for fuel type which basically retrieves the most commonly used fuel type per LSOA.
  - cellType: CODE
    cellId: 85bb93a6-af01-4ec8-bbb4-3edf038b3850 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |
        Households_with_LSOA_Boundaries = Households_with_OA_Boundaries\
        .drop('GEOGRAPHY','GEOM_BGS','LAT','LONG','BNG_E','BNG_N','LSOA21NM')\
        .group_by(F.col('LSOA21CDM'),F.col('LAD22CD'),F.col('LAD22NM'))\
        .agg(F.cast(F.avg('VUNERABILITY_INDEX'),T.IntegerType()).alias('VUNERABILITY_INDEX'),
        F.mode('FUEL_TYPE').alias('FUEL_TYPE'))\
        .join(LSOAS,F.col('LSOA21CD') == F.col('LSOA21CDM') )#.limit(5)
  - cellType: MARKDOWN
    cellId: 0b01f047-e734-4b28-b89f-3df4d0f32e0f # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### Create an LSOA map colour coded by fuel type

        1.  In data, select Households_with_LSOA_Boundaries
        2. In Type, select Area
        3. In custom, select GEOGRAPHY
        4. In Fill, base it on Fuel type
  - cellType: MARKDOWN
    cellId: 21bf3910-7c93-45e8-a17c-a73060d5b5dc # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        ## Filtering based on distance

        Rather than filtering by part of a postcode - i would like to filter based on distance of a postcode.  I will use ST_DWITHIN for a postcode and join to my dataset.  There are other ways to calculate distance such as ST_DISTANCE as well.  for Geometry data types, you can also use ST_BUFFER

  - cellType: MARKDOWN
    cellId: ef5f604e-1ea8-4e04-8d13-2b3080fc7e48 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### Step 1 - lets lets filter our postcode dataframe so it contains 1 row for the postcode we want to base our search on.  
        We will also set a distance variable
  - cellType: CODE
    cellId: 39e0f5ef-10d7-41f2-8cd7-555451c7041d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        postcode_filter = postcodes_longlat.filter(F.col('"Postcode"')=='DY13 9GN')

        distance_in_metres = 2000
  - cellType: MARKDOWN
    cellId: 9e68904b-f5db-4921-8162-6a8ae67e4a95 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "#### Step 2 - We will filter the Vunerabiity Index dataframe to select only the fields we want."
  - cellType: CODE
    cellId: efd21d6e-8ea3-4c35-a36f-b15863607b4c # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Vunerability_Index = Households_with_LSOA_Boundaries.select('VUNERABILITY_INDEX','FUEL_TYPE','LSOA21CD')
  - cellType: MARKDOWN
    cellId: 61504092-c772-4ee4-8b45-296c5bbd5ded # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "#### Step 3 - we will join with the life expectancy dataframe and finely create a join to the postcode selection.  We are using ST_DWITHIN to only include LSOA codes which are within the 'distance_in_metres' parameter which we previously set"
  - cellType: CODE
    cellId: 6b96b765-4de6-4edb-9b43-165947d0f5ce # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        life_expectancy_lsoa_distance = PostcodeLSOALookup\
        .join(geohealth_life_grouped_postcode,F.col('"Postcode"')== F.col('PCDS'))\
        .group_by(F.col('LSOA21CD')).agg(F.any_value('LSOA21NM'),
        F.any_value('GEOGRAPHY').alias('GEOGRAPHY'),
        F.avg('LIFE_EXPECTANCY').alias('LIVE_EXPECTANCY'),
        F.avg('BIOLOGICAL_AGE').alias('BIOLOGICAL_AGE'),
        F.avg('AGE_OF_DEATH').alias('AGE_OF_DEATH'))\
        .join(postcode_filter.select('"POINT"'),F.call_function('ST_DWITHIN',F.col('POINT'),F.col('GEOGRAPHY'),distance_in_metres))\
        .drop("POINT")\
        .join(Vunerability_Index,'LSOA21CD')
  - cellType: MARKDOWN
    cellId: 1c777143-1ed9-4654-ae32-aa10b36986e6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |
        #### Step 4 Create the map

        1. In Data, select life_expectancy_lsoa_distance
        2. In Type, select Area, 
        3. In Data Type select Custom
        4. In GeoJSON choose ANY_VALUE(GEOGRAPHY)
        5. In Fill base it on a measure of your choice - TIP Watch what happens when you switch to FUEL TYPE.
        6. Go back and change the postcodes/distances and refresh the cells.  TIP - you can build in select boxes etc in to Hex if you would like to experiement with that to enhance your presentation.
  - cellType: TEXT
    cellId: 5d3cb1a1-12a7-4ff4-948c-43bc32bc97df # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Below  I have created a summary dataframe to show the average vunerability index by fuel type
  - cellType: CODE
    cellId: 762a1a4f-3d0e-485b-b622-356a6f86cbce # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Vunerability fuel type
    config:
      source: Vunerability_fuel_type = life_expectancy_lsoa_distance.group_by(F.col('FUEL_TYPE')).agg(F.avg('VUNERABILITY_INDEX').alias('VUN_INDEX'))
  - cellType: MARKDOWN
    cellId: 882f4a4e-cec3-42e0-8fc9-4ede97c0638b # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### Adding Domestic Eelectricity Data
        Here I am creating a dataframe to show electricity consumption by LSOA in 2021.  Run the cell below and view the dataframe as a table display
  - cellType: CODE
    cellId: 1b875af9-5458-420b-a065-7b3d042a7a35 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Electricity = session.table('LSOA_DOMESTIC_ELECTRICITY').filter(F.col('"Year"')==2021)
  - cellType: MARKDOWN
    cellId: 8e4f9d45-fcae-4e14-9f9c-97def5b857dd # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        Repeat the same for Gas

  - cellType: CODE
    cellId: b47de0df-5fa9-460f-8815-d47a7dbdfe78 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Gas = session.table('LSOA_DOMESTIC_GAS').filter(F.col('"Year"')==2021)
  - cellType: TEXT
    cellId: 9ad78516-fc13-4344-acd5-8f052f93ef4f # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Here I am viewing the columns for just Gas
  - cellType: CODE
    cellId: d0ecffed-f936-4068-9553-1626b69bc390 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Gas.columns
  - cellType: TEXT
    cellId: a045b55c-5924-4c07-8f89-5557a3c2517f # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Because the LSOA codes are an older version (similar to the OA codes) we will use the provided lookup table to join to the new codes
  - cellType: CODE
    cellId: 648f588e-caa8-4b91-aa2d-69dd686c51ea # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: LSOA1121 = session.table('"LSOA2011 to LOSA2021 Lookup"')
  - cellType: TEXT
    cellId: 28212d6f-a04f-414e-b22e-acf4cbe158c5 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Lets join Electric and Gas Consumption together before we join to the rest of the data.
  - cellType: CODE
    cellId: 214120a3-0541-430e-8a2e-697eb7ec9038 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Elec gas lsoa
    config:
      source: |
        Elect_LSOA = Electricity.select(F.col('"LSOA code"').alias('LSOA11CD'),F.round(F.col('"Mean consumption (kWh per meter)"'),2)\
        .alias('"Mean Electric Consumption per meter"'))
        GasLSOA = Gas.select(F.col('"LSOA code"').alias('LSOA11CD'),F.round(F.col('"Mean  consumption (kWh per meter)"'),2)\
        .alias('"Mean Gas Consumption per meter"'))

        Elec_Gas_LSOA = Elect_LSOA.join(GasLSOA,'LSOA11CD')
        Elec_Gas_LSOA = Elec_Gas_LSOA.join(LSOA1121.select('LSOA11CD','LSOA21CD'),'LSOA11CD').drop('LSOA11CD')
  - cellType: MARKDOWN
    cellId: 35df47e8-a9a7-4538-946f-8e997bdde6a6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: We will Join our Life expectency by distance with our Electric and gas dataset
  - cellType: CODE
    cellId: f23a2fb4-8fd4-4a08-a1b4-4c1f51dfe685 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: vunerability_with_gas_electric_consumption = life_expectancy_lsoa_distance.join(Elec_Gas_LSOA,'LSOA21CD')
  - cellType: TEXT
    cellId: 75d8a32a-67f1-4de4-8fed-4d65f831a424 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Electric Consumption by LSOA - Below create a map using the vunerability_with_gas_electric_consumption.  Use the mean Electric Consumption per meter for the color fill.  Create another map and use the mean Gas Consumption per meter for the color fill.
  - cellType: TEXT
    cellId: e1516c76-0755-465d-9419-4da8f6b84db7 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: ""
  - cellType: MARKDOWN
    cellId: 7ac2a40a-73dc-453e-9129-df6703be0ab4 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |
        ### Visualise Weather by LSOA
        We will use the daily summary data which loads 12 years of weather data.  The weather data is by the site which is capturing the weather.  The site details include the co-ordinates of the site.
  - cellType: CODE
    cellId: a2fb160c-bf84-4d02-91f3-e937bbd0253c # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        session.table('HOURLY_FORECASTS_AND_DAILY_SUMMARIES.CURATED."Daily Summary 12 Years"')\
        .create_or_replace_view('WEATHER_DATA_DAILY_SUMMARY')

        session.table('HOURLY_FORECASTS_AND_DAILY_SUMMARIES.CURATED."PCSECTORMAPPING"')\
        .create_or_replace_view('SSPA_DETAILS')

        session.table('HOURLY_FORECASTS_AND_DAILY_SUMMARIES.CURATED."WEATHER_TYPE"')\
        .create_or_replace_view('WEATHER_TYPE')
  - cellType: MARKDOWN
    cellId: c72d5cea-01fe-4906-8a52-cb45f08a7b9f # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### Create dataframes of the weather data and the corresponding site details
        The site we only need SiteID and Latitude/Longitude.  I have used 'Make Point' to produce a point based on the cooridinates.
  - cellType: CODE
    cellId: 275c98ab-8992-4afd-80b2-12a9b355f5d5 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Weather types
    config:
      source: |-
        Weather_Daily = session.table('WEATHER_DATA_DAILY_SUMMARY')
        Weather_SSPA = session.table('SSPA_DETAILS')
        Weather_SSPA = Weather_SSPA.select(F.col('"SiteID"'), F.call_function('ST_MAKEPOINT',F.col('"LONG"'),F.col('LAT')).alias('POINT'))
  - cellType: MARKDOWN
    cellId: 11a53fa4-88ed-405a-95f4-192ebfae77b5 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #### Joining LSOA codes to the Nearest site.
        We need to work out the nearest weather site for each LSOA boundary (if the site is not contained within the boundary.). I have used ST_DWITHIN to find all the sites within a 2000 radius of the LSOA. I then used 'MIN_BY' function to only select the site that is closest based on distance between the LSOA central point and the Site.
  - cellType: CODE
    cellId: 35e7f1ee-2db4-4d77-ac85-ade315dc8c49 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        LSOASgeom = LSOAS.select('LSOA21CD','LSOA21NM','GEOGRAPHY')
        Weather_site_LSOA = LSOASgeom.join(Weather_SSPA,F.call_function('ST_DWITHIN'
                                            ,F.col('POINT')
                                            ,F.call_function('ST_CENTROID',(F.col('GEOGRAPHY')))
                                            ,2000))\
        .with_column('DISTANCE',
        F.call_function('ST_DISTANCE',
        F.col('POINT'),
        F.call_function('ST_CENTROID',
        F.col('GEOGRAPHY'))))\
        .group_by('LSOA21CD').agg(F.call_function('MIN_BY'
            ,F.col('"SiteID"')
            ,F.col('"DISTANCE"')).alias('SITE_ID')
            ,F.min('DISTANCE').alias('DISTANCE_FROM_SITE'))
  - cellType: TEXT
    cellId: e7c5494d-dcab-4bc8-880c-f4d7fefe6939 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: I have created a dataframe to sample 10 rows of data.  use a table display to see it.
  - cellType: CODE
    cellId: ff0c0dcc-db33-478d-9718-ea3d24b55a56 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Weather_DailyL = Weather_Daily.drop('GEOGRAPHY').sample(0.1).limit(10)
  - cellType: TEXT
    cellId: 881796c5-930a-4d95-8c3c-07d09e95fa74 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Here lets view the columns of the werather data
  - cellType: CODE
    cellId: 8290e0c0-15df-49c6-921f-df369f138a39 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: Weather_Daily.columns
  - cellType: TEXT
    cellId: aa3a978b-e58a-4b1e-a757-308b1ce926f9 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Here i am filtering the weather data to just reveal 2021 data, then i am creating a data column based on the 'Valid Day' column.  I am also creating a year and month number column
  - cellType: CODE
    cellId: be4ece05-0f70-40c6-bca0-17aa5c08086e # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |+
        Weather_by_LSOA = Weather_Daily.join(Weather_site_LSOA,Weather_Daily['"SSPA Identifier"']==Weather_site_LSOA['SITE_ID'])\
        .drop('"SSPA Identifier"','"DISTANCE_FROM_SITE"','SITE_ID')\
        .with_column('DATE',F.call_function('TRY_TO_DATE',(F.cast('"Valid Day (06-21Z)"',T.StringType()),'YYYYMMDD')))\
        .filter(F.year('DATE') == 2021)\
        .with_column('MONTH',F.month('DATE'))


  - cellType: TEXT
    cellId: 3d853df2-41b7-423b-8b92-35e64a80c170 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Here i am summarising the data by LSOA - i am including 'Feels Like' average temperatures for August and February.  View the Weather_Temp data in a table.
  - cellType: CODE
    cellId: 9f2129d5-362b-4ba8-823c-072449fc5112 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |
        Avg_Min_Temp_Augest = Weather_by_LSOA.filter(F.col('MONTH') == 8).group_by('LSOA21CD')\
        .agg(F.avg('"Minimum Feels Like Temperature (Wind Chill/Heat Stress) in the period 06-21Z"').alias('Avg Min Temp August'),
        F.avg('"Maximum Feels Like Temperature (Wind Chill/Heat Stress) in the period 06-21Z"').alias('Avg Max Temp August'))

        Avg_Min_Temp_February = Weather_by_LSOA.filter(F.col('MONTH') == 2).group_by('LSOA21CD')\
        .agg(F.avg('"Minimum Feels Like Temperature (Wind Chill/Heat Stress) in the period 06-21Z"').alias('Avg Min Temp February'),
        F.avg('"Maximum Feels Like Temperature (Wind Chill/Heat Stress) in the period 06-21Z"').alias('Avg Max Temp February'))

        Weather_Temp = Avg_Min_Temp_Augest.join(Avg_Min_Temp_February,'LSOA21CD')
  - cellType: TEXT
    cellId: 51e4f07b-72e0-485a-bbdf-cdaaf8bb00ab # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: Now i will combine this with the existing data.  View all data in a table and create a map.  You may want to look at wider areas to see temperature differences.
  - cellType: CODE
    cellId: 0b25b0d5-91d4-4c16-872a-7bb277711e18 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: ALL_DATA = vunerability_with_gas_electric_consumption.join(Weather_Temp,'LSOA21CD')
  - cellType: TEXT
    cellId: 59a7509b-0b36-40f0-8e02-dc775dfd9bef # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: "So you have now gone though an example of how you can combine many datasets to find information about a local area.  You may want to try the following example ideas:"
        - type: paragraph
          children:
            - text: ""
        - type: paragraph
          children:
            - text: Changing distances and postcodes
        - type: paragraph
          children:
            - text: Filtering to only show areas of a high vunerability index
        - type: paragraph
          children:
            - text: comparing one area with another area
        - type: paragraph
          children:
            - text: Seeing pattens between temperatures by year and Gas Consumption by year
        - type: paragraph
          children:
            - text: Using one of the other boundary datasets provided to group by district/country/etc
        - type: paragraph
          children:
            - text: ""
        - type: paragraph
          children:
            - text: I have created this example using Snowpark - you could do the same thing using SQL.
        - type: paragraph
          children:
            - text: ""
        - type: paragraph
          children:
            - text: HAVE FUN!!
appLayout:
  visibleMetadataFields:
    - NAME
    - DESCRIPTION
    - AUTHOR
    - LAST_EDITED
    - LAST_RUN
    - CATEGORIES
    - STATUS
    - TABLE_OF_CONTENTS
  fullWidth: false
  tabs:
    - name: Tab 1
      rows: []
sharedFilters: []
